Привет, будущий геймдевелопер! Я думаю, что многих интересует, а можно ли создать игру одному, а тем более без вложений. Вот именно об этом и пойдет речь. Я столкнулся с этим не понаслышке. Все, что написано ниже основано на собственном опыте геймдева с нуля за 3 месяца.

Начало пути. Идея и графика

Все началось в декабре 2016-го года, когда я встретился с тремя бывшими одногруппниками. 
Мы заговорили за настоящее, кто кем работает, чем занимается, и конечно же заговорили про будущее. 

Так вышло, что я графический дизайнер, двое других программисты (C# и Swift), а четвертый «перспективный». 

Четвертый рассказывал про то, какие огромные возможности в этом мире и бла бла бла… И в этот момент меня осенило. Я за столом с двумя программистами, почему бы не объединиться и не сделать что-то свое? Вот так и появились первые мысли о геймдеве. 

Первую неделю после встречи мы обсуждали идеи, определились с одной и я приступил к графике. Графику делал в векторном редакторе Adobe Illustrator, чтобы в любой момент можно было изменить разрешение, так как мы еще не совсем понимали какое именно разрешение нам нужно.

Набросал графику и на следующий же день один из программистов говорит, что не хочет продолжать, так как нашел занятие поинтереснее. За ним сливается и второй.
И тут я понял, что у меня появилась мечта и она начинает отдаляться. 

Новый год — новые силы. Программирование

Наступил новый год и я понял, что опускать руки не стоит и нужно самому довести начатое до конца. И сразу наткнулся на Corona SDK — кроссплатформенное решение для 2D игр. Есть возможность делать на PC, Android, при наличии Xcode и на Mac, iOS. 

Я не программист, по этому начал проходить туториалы прям на их сайте, очень удобно и информативно. Так я познакомился с языком программирования Lua, именно на нем придется писать, если решил использовать Corona SDK. Язык несложный, скриптовый. Lua широко используется в геймдеве для написания уровней и всяких расширений, в том числе и в игре World of Warcraft он активно используется. Статья «Lua за 15 минут» поможет быстро разобраться с языком. 

Прошел все туториалы и принял решение сначала делать под Android. Ибо у меня PC, а не Mac, да и устройств на Android в наличии было аж 4, в то время как яблочных девайсов у меня нет.

Месяца мне хватило, чтобы с консультациями от моего хорошего друга программиста (не одногруппника) набросать функционал игры. Советы он давал ценные, по этому мы стали партнерами.

Дайте больше шума. Музыка и звуки

Стал вопрос о музыкальном сопровождении. Как оказалось не так то просто найти подходящий бесплатный sound для игры, особенно если ты хочешь, чтобы еще и нравилось. Недели две я просто убил на то, чтобы найти подходящий звук и музыку, параллельно доделывал интерфейс в игре. 

Игра все больше становилась похожа на готовый продукт. И вот я нахожу подходящие звуки, но их длительность меня не устраивала, на помощь пришел Audacity. Подрезав звуки и переделав их в wav, я получил нужные мне звуковые эффекты. Сразу после этого нашлась и музыка, это был ambient с бесплатной лицензией, который пошел на резку в Audacity и был зациклен. Таким образом музыка в игре занимает меньше мегабайта и состоит из одного трека и нескольких звуков.

Важно: Бесплатные звуки и музыка должны иметь соответствующую лицензию на использование, это может быть как полностью бесплатная лицензия без указания автора, так и лицензия Creative Commons, которая позволяет бесплатно использовать, загружать и даже изменять произведения, но автора стоит указать в credits/титрах.

Звон монет и шепот денег. Монетизация

Стал вопрос о монетизации. Игра бесплатная, простая, без внутренних покупок, по этому оставался только вариант с рекламой. На Android, да и на iOS с этим проблем нет, к тому же Corona SDK поддерживает самые популярные рекламные плагины. Мой выбор пал на Appodeal. Он работают со всеми крупными сетями мобильной рекламы, для того чтобы показывать только самую дорогую рекламу внутри приложения. 

В игре использовал межстраничное объявление и видео за вознаграждение. То есть игрок сам решает, смотреть ему видео или нет, если да, то он получает вознаграждение, в моем случае он получает возможность продолжить с того же места, на котором проиграл. А вот межстраничное объявление игрок увидит после каждого проигрыша, как по мне это не мешает игровому процессу.

Игровые сервисы. Тестирование и первая публикация

Игру планировал выпустить сразу на двух торговых площадках — Google Play и Amazon. На первой аккаунт разработчика стоит 25$, а на второй бесплатно. По этому начал именно с Amazon. К тому же у меня 2 планшета от Amazon и мне близка их экосистема.

Для списка лидеров и достижений у Amazon есть Game Circle, у Google — Google Play Games Services. Проблем ни с одним, ни с другим не возникло, так как документации у Corona SDK по ним предостаточно.

На этапе тестирования дал друзьям покалацать игру, замечания себе выписал, внес поправки, а для отслеживания ошибок использовал adb logcat. Исправил баги и 6-го марта игра увидела свет на Amazon.

5 звезд на Amazon. Создание промо ролика. Публикация на Google Play

После двух положительных оценок на Amazon сразу же купил аккаунт разработчика в Google Play, цена вопроса 25$. Это пока единственные затраты на игру.

Принялся за создание промо ролика для игры. Выбор пал на Adobe After Effects, так как мне близки продукты от Adobe. Честно скажу, не было опыта в создании видео, но у меня как-то быстро получилось разобраться и на видео потратил всего день. Просто очень хотелось поскорее опубликовать игру в Google Play.

И вот момент истины, промо ролик готов, аккаунт куплен, осталось заполнить описание игры, нажать на кнопку и просто ждать.

Спустя несколько часов я получил уведомление, что игра опубликована. Это было 19-е марта 2017-го года.

Выводы

Для разработки под iOS все тоже самое, но нужен Mac с Xcode, яблочные устройства для тестирования, а за аккаунт разработчика нужно платить 99 долларов каждый год, а это уже не 25$ за Google Play. По этому если все таки речь идет о геймдеве с минимальными вложениями, то либо Amazon, где вообще платить не надо, либо Google Play, с его четвертью Франклина.

Так в одиночку, используя кроссплатформенный движок на простом и понятном для начинающих языке Lua и с минимальными затратами за 3 месяца можно с нуля сделать игру и выпустить ее. Верьте в себя и общайтесь с людьми, которые связаны с геймдевом, community очень помогает.

Удачи в начинаниях и доводите проект до конца, ибо только так можно чему-то научиться и получить опыт.

Умение писать графические шейдеры открывает перед вами всю мощь современных GPU, которые сегодня уже содержат в себе тысячи ядер, способных выполнять ваш код быстро и параллельно. Программирование шейдеров требует несколько иного взгляда на некоторые вещи, но открывающийся потенциал стоит некоторых затрат времени на его изучение.

Практически каждая современная графическая сцена являет собой результат работы некоторого кода, написанного специально для GPU — от реалистичных эффектов освещения в новейших ААА-играх до 2D-эффектов и симуляции жидкости. 

Сцена в Minecraft до и после применения нескольких шейдеров.

Цель этой инструкции


Программирование шейдеров иногда кажется загадочной черной магией. Тут и там можно встретить отдельные куски кода шейдеров, которые обещают вам невероятные эффекты и, возможно, вправду способны их обеспечить — но при этом совершенно не объясняют, что именно они делают и как добиваются столь впечатляющих результатов. Данная статья попробует закрыть этот пробел. Я сфокусируюсь на базовых вещах и терминах, касающихся написания и понимания шейдерного кода, так что впоследствии вы сами сможете менять код шейдеров, комбинировать их или писать свои собственные с нуля.

Что такое шейдер?


Шейдер — это просто программа, которая запускается на одном из графических ядер и говорит видеокарте, как нужно отрисовать каждый пиксель. Программы называются «шейдерами», поскольку они часто используются для контроля эффектов освещения и затенения («shading»). Но, конечно, нет никаких причин ограничиваться только этими эффектами.

Шейдеры пишутся на специальном языке программирования. Не беспокойтесь, вам не нужно прямо сейчас идти и изучать с нуля новый язык программирования. Мы будем использовать GLSL (OpenGL Shading Language), который имеет С-подобный синтаксис. Существуют и другие языки программирования шейдеров под различные платформы, но, поскольку их конечной целью является всё тот же запуск кода на GPU, они имеют достаточно схожие принципы.

Данная статья будет рассказывать лишь о так называемых пиксельных (или фрагментных) шейдерах. Если вам стало интересно, а какие они бывают ещё — вам следует почитать о графическом конвейере (например, в OpenGL Wiki).

Поехали!


Для наших экспериментов мы воспользуемся ShaderToy. Это позволит вам взять и начать писать шейдерный код здесь и сейчас, не откладывая это дело на потом из-за необходимости устанавливать какие-то определённые инструменты или SDK. Единственное, что вам необходимо — это браузер с поддержкой WebGL. Создавать аккаунт на ShaderToy не обязательно (только, если вы захотите сохранить там свой код).

Заметка: ShaderToy сейчас в стадии беты, так что на момент прочтения вами этой статьи некоторые нюансы его UI могут измениться.

Итак, нажимаем кнопку New в правом углу, что приведёт к созданию нового шейдера:

Маленькая чёрная стрелка под кодом компилирует и запускает шейдер.

Что здесь происходит?


Я сейчас объясню, как работает шейдер, ровно одним предложением. Вы готовы? Вот оно. Единственным предназначением шейдера является вернуть четыре числа: r, g, b и a. 
Это всё, что может и должен сделать шейдер. 

Функция, которую вы видите выше, запускается для каждого пикселя на экране. И для каждого из них она возвращает четыре вышеуказанных числа, которые и становятся цветом данного пикселя. Так работают Пиксельные Шейдеры (иногда также называемые фрагментными).

Итак, теперь у нас есть достаточно знаний для того, чтобы, например, залить весь экран чистым красным цветом. Значения каждой из компонент rgba (red, green, blue и «alpha» — то есть «прозрачность») может быть в диапазоне от 0 до 1, так что в нашем случае мы просто вернем r,g,b,a = 1,0,0,1. ShaderToy ожидает финальный цвет пикселя в переменной fragColor.

Мои поздравления! Это ваш первый работающий шейдер!
Мини-задание: сможете залить весь экран серым цветом?

vec4 — это просто тип данных, так что мы можем объявить наш цвет как переменную:
Данный пример не слишком захватывающий. У нас есть мощь сотен или тысяч вычислительных ядер, способных работать эффективно и параллельно, а мы из это пушки стреляем по воробьям, заливая весь экран одним цветом.

Давайте хотя бы нарисуем градиент. Для этого, как вы можете догадаться, нам нужно знать позицию текущего пикселя на экране.

Входные параметры шейдера


Каждый пиксельный шейдер имеет в своём распоряжении несколько полезных переменных. В нашем случае наиболее полезной будет fragCoord, которая содержит координаты x и y (а также z, если нужно будет работать в 3D) текущего пикселя. Для начала попробуем закрасить все пиксели в левой половине экрана в черный цвет, а в правой — в красный:


Заметка: для доступа к компонентам переменных типа vec4 вы можете использовать obj.x, obj.y, obj.z, obj.w или obj.r, obj.g, obj.b, obj.a. Это эквивалентные записи. Таким способом мы получаем возможность именовать компоненты vec4 в зависимости от того, чем они являются в каждом конкретном случае.

Вы уже видите проблему с кодом выше? Попробуйте нажать кнопку перехода в полноэкранный режим. Пропорции красной и черной частей экрана изменятся (в зависимости от размера вашего экрана). Для того, чтобы закрасить ровно половину экрана, нам нужно знать его размер. Размер экрана не является встроенной переменной, поскольку это нечто, что программист приложения контролирует сам. В нашем случае это ответственность разработчиков ShaderToy. 

Если что-то не является встроенной переменной, вы можете переслать эту информацию от CPU (основного кода вашего приложения) к GPU (вашему шейдеру). ShaderToy делает это за вас. Вы можете просмотреть все доступные шейдеру переменные во вкладке Shader Inputs. В GLSL они называются uniform-переменными.

Давайте исправим наш код таким образом, чтобы он корректно определял середину экрана. Для этого нам понадобится uniform-переменная iResolution:


Теперь даже при увеличении окна предпросмотра (или переходе в полноэкранный режим) мы получим поделенный ровно пополам черно-красный прямоугольник.

От разделения экрана к градиенту


Изменить наш код для получения градиентной заливки достаточно просто. Компоненты цветов могут быть в пределах от 0 до 1, и наши координаты тоже теперь представлены в том же диапазоне.


Вуаля!

Мини-задание: попробуете сами сделать вертикальный градиент? Диагональный? Как на счёт перехода между более чем двумя цветами?

Если вы не пропустили вышеуказанное задание с вертикальным градиентом, то уже знаете, что верхний левый угол имеет координаты (0;1), а не (0;0), как можно было бы предположить. Это важно, запомните это.

Рисование изображений


Развлекаться с заливкой цветом, конечно, забавно, но, если мы хотим реализовать какой-нибудь по-настоящему захватывающий эффект, наш шейдер должен быть способен принимать на вход картинку и изменять её. Таким образом мы можем написать шейдер, который может влиять, например, на отрисовку всего кадра в игре (реализовать эффекты движения жидкостей или выполнять цветокоррекцию) или наоборот, выполнять лишь отдельные операции для некоторых объектов сцены (например, реализовать часть системы освещения). 

Если бы мы писали шейдеры на какой-нибудь обычной платформе, то должны были бы передать изображение шейдеру как uniform-переменную (таким же образом, как передавалось разрешение экрана). ShaderToy делает это за нас. Есть четыре входных канала внизу:


Кликните на канале iChannel0 и выберите любую текстуру (изображение). Теперь у вас есть картинка, которая будет передана вашему шейдеру. Но есть одна проблема: функции DrawImage() у нас нет. Вы ведь помните — всё, что может сделать шейдер, это вернуть значение rgba для одного пикселя.

Итак, если мы можем лишь вернуть значение цвета, то как же нам отрисовать картинку на экране? Мы должны как-то соотнести пиксель в картинке с пикселем, для которого был вызван шейдер:


Мы можем сделать это с помощью функции texture(textureData,coordinates), которая принимает на вход текстуру и координаты (x, y), а возвращает цвет текстуры в данной точке в виде переменной типа vec4.

Вы можете соотнести пиксели текстуры и экрана как-угодно. Можно, например, растянуть текстуру на четверть экрана или нарисовать лишь её часть. В нашем случае мы всего лишь хотим увидеть оригинальное изображение:

И вот она, наша картинка!
Теперь, когда вы умеете вытягивать данные из текстуры, вы можете манипулировать ими как захотите. Вы можете растянуть или сжать изображение, поиграть с его цветами.
Давайте добавим сюда уже известный нам градиент:

Поздравляю, вы только что написали свой первый пост-процессинг эффект!

Мини-задание: сможете ли вы написать шейдер, который преобразует входную картинку в черно-белое изображение?

Заметьте, хотя мы используем статическую картинку, то, что вы видите на экране рендерится в реальном времени, много раз в секунду. Вы можете убедиться в этом, заменив во входном канале статическую картинку на видео (просто кликните на канале iChannel0 и выберите видео).

Добавляем немного движения

До этого момента все наши эффекты были статические. Мы можем делать намного более интересные вещи, используя входные параметры, предоставляемые нам разработчиками ShaderToy. iGlobalTime это постоянно увеличивающаяся переменная — мы можем использовать её в качестве основы для переодических эффектов. Давайте попробуем поиграть с цветами:

В GLSL есть встроенные функции синуса и косинуса (да и много других полезных). Компоненты цвета не должны быть негативными, так что мы используем функцию abs. 

Мини-задание: можете ли вы сделать шейдер, который будет периодически плавно делаеть картинку черно-белой, а потом снова полноцветной?

Отладка шейдеров

При написании обычных программ вы, возможно, использовали возможность отладочного вывода или логирования, но для шейдеров это не очень-то возможно. Вы можете найти какие-то отладочные средства под вашу конкретную платформу, но в общем случае лучше всего представить нужное вам значение в виде некоторой графической информации, которую вы можете увидеть в выводе невооруженным взглядом.

Заключение

Мы рассмотрели лишь базовые средства разработки шейдеров, но вы уже можете экспериментировать с ними и пробовать делать что-то своё. Просмотрите доступные на ShaderToy эффекты и попробуйте понять (или самостоятельно воспроизвести) какие-то из них.

Одна из (многих) вещей, которые я не упомянул в данной статье, это вершинные шейдеры (Vertex Shaders). Они пишутся на том же языке, но запускаются не для пикселей, а для вершин, возвращая, соответственно, новую позицию вершины и её цвет. Вершинные шейдеры занимаются, например, отображением 3D-сцены на экран.

Последнее мини-задание: сможете ли вы написать шейдер, который заменит зелёный фон (есть в некоторых видео на ShaderToy) на другую картинку или видео?

Вот и всё, что я хотел рассказать в данной статье. В следующих я попробую рассказать о системах освещения, симуляции жидкостей и разработке шейдеров под конкретные платформы.
